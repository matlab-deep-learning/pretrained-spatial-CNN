function coordinates = generateLines(pred, conf, imsize, params, fitPolyLine)
% The generateLines function extracts the lane pixel coordinates from the
% predicted probability map.

% Copyright 2021 The MathWorks, Inc.

% Number of lanes to detect.
numLanes = size(conf,1);

% Filter size for gaussian blur.
gaussFilterSize = [9,9];

% Batch size of input.
batchSize = size(pred,4);

% Create cell array to store the lane coordinates.
coordinates = cell(batchSize,numLanes);

% Threshold value below which the detections are ignored.
threshold = params.threshold;

% Suppress warnings generated by fitPolynomialRANSAC.
warning('off','vision:ransac:maxTrialsReached');

% For each image 
for batch = 1:batchSize
    for lane = 1:numLanes
        probMap = pred(:,:,lane+1,batch);
        % Smoothen the probability maps.
        probMap = imgaussfilt(probMap,'FilterSize',gaussFilterSize,'Padding','replicate');
        if conf(lane,batch)>0
            % Extract the lane points from probability maps.
            coordXY = lanePoints(probMap, threshold, imsize);
            % Remove all zeros.
            mask = (coordXY(:,1) == 0) & (coordXY(:,2) == 0);
            coordXY(mask,:) = [];
            if ~isempty(coordXY)
                % Sample points after specified gap including the last
                % point.
                last = coordXY(end,:);
                coordXY = coordXY(1:1:end,:);
                if ~all(coordXY(end,:) == last)
                    coordXY(end+1,:) = last;
                end
                if ~fitPolyLine
                    coordinates{batch,lane} = coordXY(:,1:2);
                else
                    % Fit the equation x = a.y^2 + b.y + c.
                    y = [coordXY(1,2):-1:coordXY(end,2)]';
                    % Second-degree polynomial.
                    n = 2;           
                    % Maximum allowed distance for a point to be inlier.
                    maxDistance = 3; 
                    p = fitPolynomialRANSAC([coordXY(:,2),coordXY(:,1)],n,maxDistance);
                    x = round(polyval(p,y));
                    coordXY = [x,y];
                    ids = x>=1 & x<=imsize(2);
                    coordXY = coordXY(ids,:);
                    coordinates{batch,lane} = coordXY;
                end
            end
        end
    end
end
end

function coordinates = lanePoints(probMap, thresh, imsize)
% The function lanePoints returns the row and column indexes of the maximum
% probability values.
probshape = size(probMap);
coordinates = zeros(probshape(1),2);
for i=1:probshape(1)
    % Extract the indexes of the max value.
    rowID = probshape(1)-i+1;
    cols = probMap(rowID,:);
    [value, id] = max(cols);
    if value > thresh
        coordinates(i,1) = floor(id/probshape(2)*imsize(2));
        coordinates(i,2) = floor(rowID/probshape(1)*imsize(1));
    end
end
% Ignore if number of points are less than 2.
if sum(coordinates>0)<2
    coordinates = zeros(probshape(1),2);
end
end
